2023-11-15 패스트 캠퍼스 
            한번에 끝내는 Java/Spring 웹 개발 마스터 초격차 패키지 Online
                    Part 4-1 안정적인 서비스를 위한 스프링 DATA와 Security - JPA 프로그래밍
                    ch.11 JPA 트러블 슈팅

                        01.N 1 이슈

                        JPA N + 1 이슈란?

                        1번 조회해야할 것을 N개 종류의 데이터 각각을 추가로 조회하게 되서 총 N+1번 DB조회를 하게 되는 문제이다

                        1.대상 

                        @ManyToOne 연관관계를 가진 엔티티에서 주로 발생한다. 즉, 1:N 또는 N:1 관계를 가진 엔티티에서 발생

                        2.언제 발생?

                        데이터 조회할때

                        - 즉시 로딩으로 데이터를 가져오는 경우 (N + 1 문제가 바로 발생)
                        - 지연 로딩으로 데이터를 가져온 이후에 가져온 데이터에서 하위 엔티티를 다시 조회하는 경우 (하위 엔티티를 조회하는 시점에 발생)

                        즉시 로딩 - 엔티티 조회시 연관관계에 있는 데이터까지 한번에 조회해오는 기능 fetch = FetchType.EAGER

                        지연로딩 - 엔티티 조회시점이 아닌 엔티티 내 연관관계를 참조할 때 (즉, 요청할때만) 연관된 데이터를 조회하는 기능 fetch = FetchType.LAZY

                        3.왜 발생하는거지?

                        즉시 로딩의 경우 - 연관관계의 엔티티들이 함께 조회되기 때문

                        지연 로딩의 경우 - 단순한 엔티티를 조회할 때는 N + 1 문제가 발생하지 않지만 하위 엔티티를 조회하는 경우 하위 엔티티는 프록시 객체이기 때문에 상위 엔티티를 조회하고 나서 하위 엔티티를 쿼리가 나가기 때문에 즉시 로딩과 같이 N + 1 문제가 발생

                        해결점은 무엇일까?

                        1.Fetch Join - DB에서 데이터를 가져올 때 처음부터 연관된 엔티티나 컬렉션을 한번에 같이 조회하는 방법

                        `@Query("select u from User u join fetch u.order")`

                        해당부분으로 진행할 경우 중복데이터가 발생할 경우가 존재 DISTINCT 사용

                        `@Query("select distinct u from User u join fetch u.order")`

                        2.EntityGraph 어노테이션

                        `@EntityGraph(attributePaths = {"order"})`

                        해당부분도 중복데이터가 발생할 경우가 존재하여 DISTINCT 사용 필요
            Udemy
               JavaScript 완벽 가이드 : 초급 + 고급 마스터 과정
                    76."if", "else", "else-if"로 작업하기
                        다른 조건을 생성하려면 else if를 사용
                        if 조건을 확인후 충족하지 않는다면 else if로 이동하여 조건확인
                        else의 경우는 모든 if, else if 조건이 충족되지않는경우 진행되는 구문